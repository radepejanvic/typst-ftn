#import "../funkcije.typ": todo
= Теоријске основе и постојећа истраживања
<теоријске_основе>

Ово поглавље описује основне теоријске концепте неопходне за разумевање решења (поглавље #link(<теоријски_концепти>)[2.1]), технологије коришћене у решењу (поглавље #link(<коришћене_технологије>)[2.2]) и постојећа решења (поглавље #link(<постојећа_решења>)[2.3])  

== Теоријски концепти релевантни за разумевање решења
<теоријски_концепти>
// виртуелизација, ИаЦ или ИааС, микр-клаудови

=== Виртуелизација
Виртуелизација је технологија која омогућава креирање више независних логичких окружења на једној физичкој машини. Омогућава да се један физички рачунар „подели“ на више изолованих система који функционишу као да имају сопствене ресурсе. Основни системски ресурси који се виртуелизују су процесор (CPU), меморија (RAM), складиште (_storage_) и мрежни интерфејси (_network interfaces_) @redhat_virtualization. Основни концепти виртуелизације су виртуелне машине (_virtual machine, VM_) и хипервизори (_hipervisors_).

Виртуелна машина представља софтверски дефинисано изоловано окружење са сопственим оперативним системом, меморијом, процесором и мрежним интерфејсима. Ресурси виртуелне машине (_guest machine_) се добијају од физичке машине (_host machine_), али су логички издвојени тако да њихово окружење функционише независно од других виртуелних машина @aws_virtualization.

Хипервизор, познат и као менаџер виртуелних машина (_virtual machine monitor_, VMM), представља софтвер који омогућава деобу физичких ресурса рачунара на више виртуелних окружења. Он управља креирањем, доделом ресурса и радом виртуелних машина. Посредује између физичког хардвера (_host_) и виртуелних система (_guests_) који користе његове ресурсе. 

Постоје две врсте хипервизора. Tип 1 (_native_, _bare-metal_) на слици #link(<fig:hipervizor-1>)[1], инсталира  се директно на хардвер уместо оперативног система. Ресурси виртуелних машина директно се мапирају на хардвер. Овај тип је популаран у ентерпрајз окружењима и серверским системима. Тип 2 (_hosted_) на слици #link(<fig:hipervizor-2>)[2], инсталира се као апликација на постојећи _host_ оперативни систем. Ресурси и инструкције виртуелних машина најпре се мапирају на _host_ оперативни систем који их потом прослеђује хардверу @redhat_virtualization @aws_virtualization.  

// #link(<fig:hipervizori>)[2]

// #figure(
//     grid(
//         columns: 2,
//         align: horizon,
//         image("../slike/hipervizor-tip-1.svg", width: 90%),
//         image("../slike/hipervizor-tip-2.svg", width: 90%)
//     ),
//     caption: [
//         Типови хипервизора: лево – тип 1 (_native_, _bare-metal_); десно – тип 2 (_hosted_).
//     ]
// )<fig:hipervizori>


#figure(image("../slike/hipervizor-tip-1.svg", width: 50%),
caption: [
    Хипервизор тип 1 (_native_, _bare-metal_).
]
)<fig:hipervizor-1>

#figure(image("../slike/hipervizor-tip-2.svg", width: 50%),
caption: [
    Хипервизор тип 2 (_hosted_).
]
)<fig:hipervizor-2>

Бенефити виртуализације се огледају у: 
- смањењу потребне физичке инфраструктуре
// , више _guest_ машина на једној _host_ машини смањује број неопходних физичких рачунара
- смањењу времена неисправности (_downtime_), у случају неке катастрофе или неочекиваног гашења физичког рачунара, виртуализована окружења се лакше и брже премештају и постављају на друге физичке машине
- повећању ефикасности и продуктивности тимова који одржавају инфраструктуру
- једноставнијем тестирању и креирању тест окружења која су идентична продукционим
- еколошком унапређењу и штедњи електричне енергије @ibm_virtualization_benefits

=== Контејнеризација
Контејнеризација представља технологију која омогућава покретање апликација у изолованим окружењима под називом контејнери (_containers_). За разлику од виртуелних машина, које емулирају цео хардвер и покрећу сопствени оперативни систем, контејнери деле језгро (_kernel_) _host_ оперативног система и користе заједничке системске ресурсе, али су логички изоловани један од другог. Оваква архитектура омогућава значајно мању потрошњу ресурса, брже покретање и лакше распоређивање апликација у различитим окружењима.

Контејнер је стандардизована јединица софтвера која обједињује апликацију и све њене зависности, библиотеке, конфигурационе датотеке и системске променљиве у један преносиви пакет. Захваљујући томе, апликација ће се понашати исто без обзира на то да ли се извршава на локалном рачунару, серверу или облаку. 
// Управљање изолацијом и ресурсима у контејнерима најчешће се ослања на механизме control groups (cgroups) и namespaces у Linux оперативним системима.

Главна предност контејнеризације у односу на класичну виртуелизацију јесте њена ефикасност. Будући да се више контејнера може покретати на једном оперативном систему без потребе за додатним хипервизором, трошак меморије и процесорских ресурса је знатно мањи, а време покретања апликација драстично краће. Сваки контејнер се извршава као посебан процес у корисничком простору (_user space_), док све виртуелне машине захтевају покретање комплетног оперативног система, што их чини знатно „тежим“ и споријим. Овакав приступ омогућава већу густину апликација по систему и једноставније оркестрирање @docker_what_container. 

#figure(image("../slike/kontejnerizacija.svg", width: 70%),
caption: [
    Контејнеризација.
]
)<fig:kontejnerizacija>

Иако представљају различите технологије, контејнери и виртуелне машине се често користе заједно, јер се њихове предности међусобно допуњују. Виртуелне машине обезбеђују пуну изолацију и сигурност на нивоу хардвера, док контејнери пружају брзину, лакоћу распоређивања и скалабилност апликација. Комбиновањем ова два приступа (слика #link(<fig:virt-kont-kombinacija>)[4]) могуће је покретати више контејнеризованих апликација унутар једне виртуелне машине, чиме се постиже већа флексибилност, боља искоришћеност ресурса и лакше управљање у хетерогеним или мулти-клауд окружењима.

#figure(image("../slike/virt-kont-kombinacija.svg", width: 80%),
caption: [
    Комбинација виртуелних машина и контејнера.
]
)<fig:virt-kont-kombinacija>

=== Инфраструктура као код (_Infrastructure as Code_)
Инфраструктура као код (_Infrastructure as Code_, IaC) представља начин аутоматизацијe подизања и управљања инфраструктуром. Oбухвата конфигурисање,  постављање (_deployment_) и управљањe виртуелним окружењима на физичким машинама. Виртуелна окружења могу бити виртуелне машине или контејнери, а њихова конфигурација се описује машински читљивим кодом.

Најчешћи формати дефинисања конфигурације јесу YAML и JSON датотеке. Конфигурацјију представљају дефиниције виртуелних машина, контејнера, мрежних ресурса, складишта и зависности апликација. 

IaC се може реализовати на два начина:  
- декларативно (_declarative_), дефинише се жељено стање у ком систем треба да се налази, а IaC алат сам закључује како да га постигне @feng_imperative_vs_declarative_iac ("желим 3 сервера са следећом конфигурацијом" @ibm_iac)
- императивно (_imperative_), дефинише се сет инструкција (_playbooks_) које IaC алат треба да испрати корак по корак @feng_imperative_vs_declarative_iac ("прво креирај сервер, онда инсталирај софтвер, па конфигуриши подешавања" @ibm_iac)

Представљање инфраструктуре помоћу кода омогућава примену свих концепата који су до сада били незаобилазни у развоју софтвера, као што су верзионисање, ревизија и праћење промена, примена агилних метода, аутоматизовано тестирање и интеграција. Инфраструктурне промене је могуће третирати на исти начин као промене у апликацијском коду, што повећава поузданост, репродуктивност и лакоћу одржавања окружења.

=== Рачунарство у облаку (_Cloud Computing_)
Рачунарство у облаку (_cloud computing_) представља испоруку рачунарских ресурса и складишних капацитета као услуге преко интернета. Релизује се тако што корисник приступа удаљеним серверима складиштеним у огромним центрима података (_data centers_) у власништву провајдера услуге. На овај начин елиминише се потреба за локалним хардвером и омогућава скалабилност, висока доступност и флексибилност коришћења ресурса.

Главна мана оваквог приступа јесте центрлизовано управљање комплетним рачунарским ресурсима (рачунарском снагом и складиштеним подацима) које доводи до следећих проблема: 
- кашњење (_latency_) у трансферу и обради података, као последица удаљености између крајњег корисника и облака 
- зависност од интернет конекције, без које корисник нема приступ сопственим подацима и рачунарским ресурсима у облаку
- загушеност мреже (_bandwidth load_), све популарнији паметни системи (_internet of things_, IoT), паметни аутомобили, авиони и остали уређаји који шаљу континуиране метрике на облак додатно оптерећују мрежу 
- безбедносни ризици, подаци се обрађују и складиште на удаљеним серверима што отвара питање приватности и контроле
- регулаторна и правна ограничења, неке организације не смеју да складиште податке ван државе или сопственог система

=== Рачунарство на ивици (_Edge Computing_)
Ови изазови постају све израженији са растом броја повезаних уређаја и потребом за обрадом података у реалном времену, што је подстакло развој нових концепата као што је рачунарство на ивици (_edge computing_). Суштина овог приступа јесте премештање рачунарских ресурса ближе крајњим корисницима, односно изворима података који се налазе на ивици мреже (_network edge_). На тај начин се смањује кашњење у комуникацији, побољшава одзив система и омогућава ефикаснија обрада података у децентрализованом окружењу @cao2020overview.

Развој рачунарства на ивици не замењује класично рачунарство у облаку, већ га допуњује и омогућава координисан рад две парадигме. Рачунарство у облаку и даље има кључну улогу у централизованој обради великих количина података, дубинској аналитици и дугорочним одлукама, док рачунарство на ивици преузима обраду података ближе извору, смањује кашњење, оптерећење мреже и омогућава обраду у реалном времену. У пракси, чворови на ивици (_edge nodes_) могу локално обрадити и филтрирати податке, а резултате слати у облак за даљу анализу @cao2020overview.

=== Микро облак (_Micro Cloud_)
У последњих неколико година све је популарније постављање мањих _data center_-a на ивици мреже. Географски распоређени сервери малих размера, организовани као микро облаци (_micro clouds_). Инфраструктура се дефинише  независно од физичких машина и њихових оперативних система, применом IaC-а и  концепата виртуелизације и контејнеризације. Такав приступ омогућава ефикасније коришћење ресурса чак и у хетерогеним кластерима  @simic2021microclouds.

== Технологије коришћене у решењу
<коришћене_технологије>

Алат је развијен у _Go_ програмском језику. Кориснички интерфејс је реализован као CLI апликација уз употребу библиотеке _Cobra_ @spf13_cobra, која омогућава једноставно дефинисање команди и аргумената.
Архитектура система је модуларна, састоји се од централног (_core_) дела који дефинише опште интерфејсе и позадинских модула који могу бити дефинисани од стране корисника и прикључени у алат помоћу конфигурационе датотеке. 

У склопу алата имплементиран је један позадински модул који користи _Vagrant_ @hashicorp_vagrant и _go-vagrant_ @matcuk_go_vagrant библиотеку за подизање и управљање животним циклусом чворова.  Конфигурациони фајл је дефинисан у YAML формату, док су скрипте за провизионисање (_provisioning_) и покретање сервиса реализоване као _Shell_ скрипте. _VirtualBox_ @virtualbox_homepage хипервизор је коришћен као провајдер виртуелизације. _Control plane_ и сервиси покретани на виртелним машинама су спаковани у _Docker_ @docker_homepage контејнере и њихово покретање је вршено помоћу _Docker Compose_ @docker_compose_docs алата.   

=== _Cobra_
_Cobra_ је _Go_ библиотека отвореног кода за креирање CLI апликација. Омогућава дефинисање команди, подкоманди и аргумената. Подржава обавезнa и опциона поља, као и логичку организацију команди у хијерархију. У алату се користи за имплементацију интерфејса који омогућава покретање и управљање виртуелним окружењима и сервисима на њима.

=== _Vagrant_
_Vagrant_ је алат отвореног кода за аутоматизовано креирање и управљање виртуелним машинама. Омогућава дефинисање конфигурације виртуелних окружења у машински читљивим фајловима (_Vagrantfile_), а затим аутоматско подизање, провизионисање и уништавање тих окружења. Подржава различите хипервизоре као што су _VirtualBox_, _VMware_ и други. Омогућава доследно и преносиво развојно окружење за више платформи .

_Vagrantfile_ се пише у _Ruby_ програмском језику. У њему се одређују основне карактеристике виртуелних окружења, као што су хипервизор, системски ресурси, мрежна подешавања и скрипте или алати за провизионирање. Такође омогућава аутоматско извршавање скрипти за инсталацију зависности и подешавања окружења. Могуће је дефинисање конфигурације за произвољан број окружења. 

_Vagrant_ долази са унапред подешеним опцијама за удаљени приступ виртуелним окружењима помоћу SSH протокола. 

=== _VirtualBox_
_VirtualBox_ је хипервизор типа 2 (_hosted_), инсталира се на _host_ оперативни систем као апликација. Нуди емулaцију хардвера и подршку за различите _guest_ системе. Kорисник може да покрене _guest_ оперативни системе као независне виртуелне машине у оквиру _host_-a. 

Поред основне виртуелизације, _VirtualBox_ подржава више мрежних режима (NAT, _bridged_, _host-only_), дељење директоријума и пренос датотека између _host_ и _guest_ система, као и подршку за USB уређаје и снимке стања (_snapshots_) који омогућавају враћање виртуелне машине у претходно стање.

У оквиру овог алата, _VirtualBox_ служи као хипервизор и провајдер виртуелних машина у склопу _Vagrant_-a.

=== _Docker_ и _Docker Compose_

_Docker_ је платформа за контејнеризацију. Oмогућава паковање апликације и свих њених зависности у преносиви контејнер. Контејнери се извршавају из _Docker_ слика (_images_), које представљају шаблоне са свим неопходним зависностима, оперативним окружењем, библиотекама и конфигурацијама за покретање апликације. _Docker_ слике се дефинишу помоћу _Dockerfile_ датотека. 
_Docker_ такође подржава употребу дељених директоријума (_volumes_) за трајно складиштење података изван животног циклуса контејнера.

_Docker Compose_ је алат који омогућава дефинисање и управљање више повезаних _Docker_ контејнера као једним системом. Конфигурација се дефинише у YAML датотеци (`docker-compose.yml`), у којој се описују појединачни сервиси, њихове слике, мрежне поставке и дељени директоријуми. Овакав приступ поједностављује оркестрацију комплексних апликација које се састоје од више међусобно зависних контејнера и омогућава покретање целокупног окружења једном командом.

Kоришћени су у склопу _Shell_ скрипти за провизионирање, за покретање претходно докеризованих сервиса из _Constellations_ пројекта. Такође се користе и за покретање _Control plane_-а на _host_ машини.

== Постојећа решења
<постојећа_решења>

У овом поглављу је обрађено неколико неколико постојећих алата који омогућавају аутоматизовање покретања и управљање виртуелним окружењем. Ниједно од предложених решења не одговара на функционалне захтеве проблема у целости или то ради на сувише комплексан начин.

=== _Terraform_
_Terraform_ @hashicorp_terraform је IaC алат који омогућава декларативно управљање инфраструктуром. Користи сопствени језик HCL (_HashiCorp Configuration Language_) за опис жељеног стања система, што омогућава да алат сам израчуна кораке потребне за постизање тог стања. _Terraform_ може да креира и управља ресурсима на различитим провајдерима, као што су платформе у облаку (AWS, _Azure_, GCP) или локални провајдери као што је _VirtualBox_.

=== _Ansible_ 
_Ansible_ @ansible_docs је IaC алат за аутоматизацију конфигурације и управљање системима. Користи декларативне YAML _playbook_-ове за дефинисање корака које треба извршити на једном или више _host_-ова, као што су инсталација софтвера, копирање фајлова и покретање скрипти. _Ansible_ се ослања на SSH за повезивање са _host_-овима и не захтева инсталиран агент на њима, што га чини погодним за управљање постојећим серверима или виртуелним машинама.