#import "../funkcije.typ": todo
= Имплементација система
<имплементација_система>

Имплементација представља фазу у којој је дефинисана архитектура система добила своју конкретну софтверску форму. Циљ је био развити CLI алат који омогућава једноставно подизање, конфигурисање и управљање виртуелним машинама у локалном окружењу. Развој је заснован на модуларном приступу који раздваја функционалности на више логичких целина, CLI, _Core_ и _Backend_ слој, чиме се постиже лакше одржавање и проширивост решења.

Имплементација је реализована у програмском језику _Go_, који омогућава компајлирање у једну извршну датотеку. _Backend_ је заснован на _Vagrant_-у и _VirtualBox_-у, док се параметри окружења дефинишу путем YAML конфигурационих датотека.

У наставку поглављу биће описанa имплементација система, укључујући организацију пројекта и садржај директоријума (поглавље #link(<организација_пројекта>)[5.1]), _Core_ компоненту и интерфејсе (поглавље #link(<core>)[5.2]), учитавање и валидацију конфигурационих фајлова (поглавље #link(<конфигурација>)[5.3]), CLI компоненту (поглавље #link(<cli>)[5.4]) и _VagrantBackend_ компоненту (поглавље #link(<vagrant_backend>)[5.5]). Посебно су обрађене _shell_ скрипте за иницијализацију окружења, покретање и заустављање чворова и управљање _control plane_-ом (поглавље #link(<shell_skripte>)[5.6]).

== Организација пројекта
<организација_пројекта> 
Пројекат је организован по _Go_ конвенцијама, са јасно раздвојеним пакетима по функционалним целинама. Таква структура омогућава лакшу навигацију кроз код, изолацију компоненти и једноставно проширивање система новим функционалностима.

У табели #link(<tbl:proj>)[3] приказана је структура пројекта и намена сваког директоријума. Табела пружа јасан преглед организације изворног кода и служи као оријентир за даље разумевање имплементације система.

#figure(
table(
  columns: 2,
  align: (col, row) => (left, left).at(col),
  inset: 6pt,
  [Директоријум], [Опис],
  [`/aliases`], [Садржи дефиниције алијаса за CLI команде.],
  [`/cmd`], [Главна улазна тачка CLI апликације.],
  [`/constants`], [Садржи глобалне константе које укључују описе команди и подразумеване вредности.],
  [`/internal/core`], [Језгро система, овде се налази централни интерфејс _Backend_ и основне структуре.],
  [`/internal/backends`], [Имплементације конкретних _Backend_-а. Тренутно само _VagrantBackend_.],
  [`/config`], [Садржи опис и учитавање конфигурације.],
  [`/utils`], [Помоћне функције.],
  [`/vagrant`], [Радни директоријум у ком се налазе све скрипте које се преносе на виртуелне машине и генерисани _Vagrantfile_ који се користи при подизању окружења.],
),
  caption: [Структура пројекта.]
)<tbl:proj>

#pagebreak()

== _Core_ компонента
<core>
_Core_ компонента представља апстракциони ниво система. Налази се у `/internal/core` директоријуму. Дефинише заједнички интерфејс који сваки _Backend_ мора да имплементира. Помоћу интерфејса се обезбеђује јединствен начин управљања инфраструктуром без обзира на конкретну технологију која стоји иза ње. 

На листингу #link(<lst:backend_interface>)[1] приказан је `Backend` интерфејс који садржи све функционалности управљања животним циклусом виртуелних машина и покретање и заустављање сервиса на њима, као што је описано у претходном поглављу у табели #link(<tbl:functionalnosti>)[1]. 

#figure(
```go
type Backend interface {
	Setup(conf *config.Config) error
	Create(vms ...string) error
	Stop(vms ...string) error
	Resume(vms ...string) error
	Reload(vms ...string) error
	ShutDown(vms ...string) error
	Destroy(vms ...string) error
	StartNodes(vms ...string) error
	StopNodes(vms ...string) error
}
```,
    caption: [Дефиниција `Backend` интерфејса.]
)<lst:backend_interface>

У _Core_ компоненти такође је дефинисана метода фабрике (енгл. _factory method_) _Backend_-a, помоћу које се добија иснтанца одговарајуће имплементације _Backend_-a на основу параметара конфигурационе датотеке. На листингу #link(<lst:backend_factory>)[2] приказана је та метода. 

#figure(
```go
func NewBackend(name string) (Backend, error) {
	switch name {
	case "vagrant":
		return backends.NewVagrantBackend()
	default:
		return nil, fmt.Errorf("unsupported backend: %s", name)
	}
}
```,
    caption: [Метода фабрике _Backend_-а.]
)<lst:backend_factory>

// TODO: Dodaj jos u core kako se pokrece control plane, jer bi i to bio bitan faktor implementacije - pasus ili 2

== Конфигурација
<конфигурација>
Конфигурациона датотека у YAML формату дефинише параметре окружења, као што су број виртуелних машина, дистрибуција оперативног система, ресурси и мрежне поставке. На овај начин се омогућава лако прилагођавање и репродукција развојног окружења. Опис структуре конфигурационе датотеке дат је у табели #link(<tbl:yaml>)[2]  у претходном поглављу. 

Конфигурациона структура, `Config`, њено учитавање и валидација се налазе у директоријуму `/config`. За потребе учитавања конфигурационе YAML датотеке коришћена је _gopkg.in/yaml.v3_ библиотека и њена `Unmarshal()` метода. 

Валидација се врши у складу са типом и значењем сваког поља, како би се обезбедила исправност и компатибилност конфигурације са системом. Примењене провере укључују: 
- `vmCount`, `cpus`, `memory` - позитивни цели бројеви
- `osDistro`, `osVersion`, `nameBase`, `backendType` - непразни стрингови
- `guestPort`, `hostPort` - позитивни цели бројеви између 1024 и 65535 
- `gui` - булова вредност

#pagebreak()

На листингу #link(<lst:yaml_config>)[3] приказан је пример исправне конфигурационе YAML датотеке која се парсира и учитава у структуру `Config`. На листингу #link(<lst:yaml_config>)[4] приказана је дефиниција конфигурационе структуре `Config`.

#figure(
```yaml
vmCount: 3  
osDistro: "ubuntu/jammy64"
osVersion: "20241002.0.0"
cpus: 4
memory: 4096
gui: false
ipBase: "192.168.56."
guestPort: 6739
hostPortBase: 11000
nameBase: "node"
backendType: "vagrant"
```,
    caption: [Пример исправне конфигурационе YAML датотеке.]
)<lst:yaml_config>

#figure(
```go
type Config struct {
	VMCount      int    `yaml:"vmCount"`
	OSDistro     string `yaml:"osDistro"`
	OSVersion    string `yaml:"osVersion"`
	CPUs         int    `yaml:"cpus"`
	Memory       int    `yaml:"memory"`
	GUI          bool   `yaml:"gui"`
	IPBase       string `yaml:"ipBase"`
	GuestPort    int    `yaml:"guestPort"`
	HostPortBase int    `yaml:"hostPortBase"`
	NameBase     string `yaml:"nameBase"`
	BackendType  string `yaml:"backendType"`
}
```,
    caption: [Дефиниција конфигурационе структуре `Config`.]
)<lst:config>

== CLI компонента 
<cli>
Командни интерфејс представља улазну тачку система и омогућава кориснику да управља свим функционалностима алата кроз командну линију. Свака команда активира специфичан ток извршавања унутар система, који се преко _Core_ слоја прослеђује одговарајућем _Backend_-у. Тако је обезбеђена апстракција између корисничког интерфејса и логике управљања виртуелним машинама и _control plane_-ом.

Организација кода CLI компоненте прати модуларан приступ. Свака команда је дефинисана у сопственој _Go_ датотеци у директоријуму `/cmd`. Алијаси, кратки и дуги описи команди дефинисани су у посебним датотекама унутар `/aliases` и `/constants` директоријума респективно. То омогућава једноставно додавање или модификацију команди без измене основне логике. 

За управљање стаблом команди и аргументима командне линије коришћена је библиотека _Cobra_, која омогућава лаку дефиницију подкоманди и аутоматско генерисање помоћи (енгл. _help_).

На листингу #link(<lst:aliases>
)[4] приказана је `/aliases/aliases.go` датотека, која дефинише алијасе свих команди. Овим се омогућава да _Cobra_ библиотека препозна и аутоматски понуди исправне облике команде у случају погрешног корисничког уноса.

#figure(
```go
package aliases

const (
	CreateAlias     = "create"
  CreteAlias      = "crete"
  CrateAlias      = "crate"
	// ...
)

var (
	CreateAliases      = []string{CreateAlias, CreteAlias, CrateAlias}
  // ...
)
```,
    caption: [Приказ садржаја `/aliases/aliases.go` датотеке.]
)<lst:aliases>

На листингу #link(<lst:short_desc>)[6] приказана је `/constants/short.description.go` датотека, која дефинише кратке описе свих команди. Овим се омогућава да _Cobra_ библиотека, приликом приказа помоћи или листању доступних команди, уз сваку прикаже сажет опис намене.

#figure(
```go
package constants

const (
	ShortCreateDesc     = "Create one or more virtual machines"
  // ...
)
```,
    caption: [Приказ садржаја `/constants/short.description.go` датотеке.]
)<lst:short_desc>

На листингу #link(<lst:long_desc>)[7] приказана је `/constants/long.description.go` датотека, која дефинише детаљне описе свих команди. Ови описи се приказују када корисник затражи проширену помоћ за одређену команду, 
// TODO: mozda ovo da izbacim
пружајући додатне информације о њеној употреби, параметрима и очекиваном понашању.

#figure(
```go
package constants

const (
	LongCreateDesc = `Creates the virtual machines specified by name. 
If no names are provided, all virtual machines in the environment will be created.

Example:
- wormhole create
- wormhole create node0 node1`
  // ...
)
```,
    caption: [Приказ садржаја `/constants/long.description.go` датотеке.]
)<lst:long_desc>

На листингу #link(<lst:command>
)[8] приказан је пример имплементације _Cobra_ команде. Овај пример илуструје употребу претходно дефинисаних константи за алијасе, кратке и дуге описе команди.

#figure(
```go
var CreateCmd = &cobra.Command{
	Use:     "create [VM names...]",
	Aliases: aliases.CreateAliases,
	Short:   constants.ShortCreateDesc,
	Long:    constants.LongCreateDesc,
	Run: func(cmd *cobra.Command, args []string) {
    // ...
	},
}
```,
    caption: [Пример имплементације _Cobra_ команде.]
)<lst:command>

== _VagrantBackend_ компонента 
<vagrant_backend>
_Backend_ слој представља део система задужен за директну комуникацију са платформом за виртуелизацију и извршавање операција над виртуелним машинама. У оквиру овог решења реализован је _VagrantBackend_, који се ослања на алат _Vagrant_ и библиотеку _go-vagrant_ ради аутоматизације креирања, конфигурисања и управљања виртуелним окружењима. Ова компонента спаја функционалности дефинисане у _Core_ компоненти са конкретним механизмима које обезбеђује _Vagrant_.

=== Генерисање _Vagrantfile_-a
Генерисање _Vagrantfile_-a представља централну функционалност овог модула. На њему се заснива дефинисање окружења које ће се касније покретати помоћу _Vagrant_-a.

_VagrantBackend_ користи предефинисан _Vagrantfile_ шаблон, смештен у `/internal/backends/vagrantfile_template.rb` датотеку. На основу шаблона и конфигурационе YAML датотеке генерише излазну _Vagrantfile_ датотеку која се користи за покретање окружења. 

Користи _text/template_ библиотеку како би уградио дефинисане вредности у шаблон. Замењује делове датотеке који се налазе у двоструким витичастим заградама (`{{...}}`) са одговарајућим атрибутом структуре `TemplateData` која садржи опис окружења прилагођен _Vagrantfile_ шаблону. На листингу #link(<lst:vagrantfile_template>)[9] приказан је садржај _Vagrantfile_ шаблона са претходно описаним деловима зa замену,  обухваћеним двоструким витичастим заградама.

#figure(
```rb
Vagrant.configure("2") do |config|
    config.vm.box = "{{ .Box }}"
    config.vm.box_version = "{{ .BoxVersion }}"

    # Resource configuration 
    config.vm.provider "virtualbox" do |vb|
        vb.memory = {{ .Memory }}        
        vb.cpus = {{ .CPUs }} 
        vb.gui = {{ .GUI }}             
    end

    # Common provisioning script for all VMs
    config.vm.provision "shell", name: "install-dependencies", path: "install_dependencies.sh"

    # Create node VMs
    {{- range .VMs}}
    config.vm.define "{{ .Name }}" do |node|
        node.vm.hostname = "{{ .Hostname }}"
        node.vm.network "private_network", ip: "{{ .IP }}"
    end
    {{- end }}
end
```,
    caption: [_Vagrantfile_ шаблон.]
)<lst:vagrantfile_template>

Како се шаблон не би морао учитавати са диска сваки пут и како би се омогућило да једном компајлирана извршна датотека не зависи од њега, _Vagrantfile_ шаблон се уграђује у њу помоћу _embed_ библиотеке. На листингу #link(<lst:embed>)[10] приказан је део кода у склопу _VagrantBackend_-a задужен за то.  

#figure(
```go
//go:embed vagrantfile_template.rb
var vagrantfileTemplate string
```,
    caption: [Уграђивање _Vagrantfile_ шаблона у извршну датотеку.]
)<lst:embed>

=== Имплементација функционалности 
<имплементација>
_VagrantBackend_ имплементара сваку функцију дефинисану у _Backend_ интерфејсу. Функционалности су имплементиране ослањајући се на _go-vagrant_ библиотеку или на директно позивање _Vagrant_ команди. Функционалности су подељене у два скупа: 
- за управљање животним циклусом виртуелних машина 
- за покретање и засутављање сервиса на њима.  

Функционалности за управљање животним циклусом виртуелних машина имплементиране су тако да се ослањају на `VagrantClient` атрибут структуре `VagrantBackend` приказане на листингу #link(<lst:vagrant_struct>)[11].  

#figure(
```go
type VagrantBackend struct {
	client *vagrant.VagrantClient
}
```,
    caption: [Дефиниција `VagrantBackend` структуре.]
)<lst:vagrant_struct>

Функционалности за покретање и заустављање сервиса су имплементиране као омотачи око удаљених позива _shell_ скрипти на виртуелним машинама помоћу `vagrant ssh` команде, уместо ослањања на _VagrantClient_ као у претходном случају.

На листингу #link(<lst:start_nodes>)[12] приказана је поједностављена имплементација функције `StartNodes`. _Flag_-ovi `-t` и `-c` служе за алокацију псеудо TTY-a (енгл. _teletypewriter_) и извршавање наведене команде без отварања интерактивне SSH сесије респективно, односно омогућавају да се _ouput_ покренутих скрипти преусмери на терминал, али да терминал не остане заробљен у SSH сесији. 

#figure(
```go
func (v *VagrantBackend) StartNodes(vms ...string) error {
	// ...
		cmd := exec.Command("vagrant", "ssh", "-t", vm, "-c", "bash /vagrant/node_start.sh")
	// ...
}
```,
    caption: [Имплементација функције `StartNodes`.]
)<lst:start_nodes>

== _Shell_ скрипте
<shell_skripte>
У овом поглављу описане су основне _shell_ скрипте које омогућавају подизање и конфигурацију развојног окружења. Скрипте покривају инсталацију зависности, покретање и заустављање сервиса на виртуелним машинама, као и подизање _control plane_-а на _host_ машини. Скрипте које се покрећу на виртуелним машинама налазе се у директоријуму `/vagrant` који се монтира на истоимени директоријум на виртуелним машинама. 
- `install_dependencies.sh` - скрипта која инсталира све неопходне зависности и сервисе на виртуелној машини, користи се током иницијализације сваке виртуелне машине у склопу _Vagrantfile_ провизионисања (листинг #link(<lst:vagrantfile_template>)[9]). 
- `node_start.sh` и `node_stop.sh` - скрипте за покретање и заустављање сервиса на виртуелним машинама, конкретно _c12s/star_ сервиса, изврњавају се преко _Vagrant_ SSH сесије.  
- `node.env` - конфигурациони фајл који дефинише променљиве окружења специфичне за сваку виртуелну машину, користи се приликом извршавања `install_dependencies.sh` скрипте.
- `control_plane_start.sh` - скрипта која покреће _control plane_ сервисе на _host_ машини и омогућава да CLI алат управља свим чворовима у систему.
Ово поглавље ће детаљније приказати садржај и ток извршавања сваке скрипте. 

#pagebreak()

=== Инсталација зависности
Инсталација зависности се одвија приликом првог покретања виртуелне машине у склопу провизионисања. Реализована је у склопу `install_dependencies.sh` скрипте. 

Процес инсталације обухвата следеће кораке: 
1. додавање званичног _Docker_ GPG кључа
2. инсталација _Docker_ i _Docker Compose_ алата
3. покретање _Docker_-a
4. додавање предефинисаног _Vagrant_ корисника у Docker групу
5. инсталација последње верзије _Go_-a и _Git_-a 
6. клонирање _c12s/tools_ репозиторијума на путању `/home/vagrant/tools` уколико већ не постоји
7. покретање инсталационе скрипте `install.sh` из _c12s/tools_-а како би се инсталирали сви неопходни _Constellations_ сервиси 
8. конфигурисање `node.env` датотеке на основу дефинисаних параметара виртуелне машине
9. додавање дозволе за покретање `node_start.sh` скрипти

На листингу #link(<lst:node_env>)[13] приказане је део променљивих окружења дефинисаних у датотеци `node.env`. Оне се аутоматски генеришу за сваки чвор током процеса иницијализације и садрже информације неопходне за правилно повезивање чворова са _control plane_-ом и међусобну комуникацију у оквиру кластера.

#figure(
```bash
STAR_HOSTNAME # назив или адреса чвора  
NATS_HOSTNAME # назив или адреса чвора на ком је покренут control plane (host)  
NATS_ADDRESS # назив или адрса чвора на ком је покренут control plane + порт 4222
BIND_ADDRESS # адреса на којој је чвор доступан осталим чворовима  
```,
    caption: [Променљиве `node.env` датотеке.]
)<lst:node_env>

=== Покретање сервиса на виртуелним машинама 
Скрипта `node_start.sh` задужена је за покретање свих потребних _Constellations_ сервиса на појединачном чвору. Извршава се након што је успешно завршено провизионисање и конфигурисање окружења. 

Процес покретања обухвата следеће кораке: 
1. извоз (енгл. _export_) вредности из `node.env` датотеке у окружење виртуелне машине
2. брисање и поновно креирање директоријума на путањи `/etc/c12s` са постављеним свим пермисијама за све кориснике (0777)
3. покретање сервиса дефинисаних у `node.yml` датотеци помоћу _Docker Compose_-a
4. компајлирање _c12s/star_ сервиса и креирање `star` извршне датотеке на `/home/vagrant/star` путањи  
5. покретање `star` извршне датотеке у позадини и записивање PID-a у `/etc/c12s/star.pid` датотеку

На листингу #link(<lst:node_yaml>)[14] приказани су сервиси дефинисани у оквиру `node.yml` датотеке који се покрећу на сваком чвору помоћу _Docker Compose_-a.

#figure(
```yaml
version: "3.8"

services:
  node_exporter:
    # ...
  cadvisor:
    # ...
  starometry:
    # ...
```,
    caption: [Сервиси дефинисани у `node.yml` датотеци.]
)<lst:node_yaml>

=== Заустављање сервиса на виртуелним машинама
Скрипта `node_stop.sh` служи за контролисано заустављање свих _Constellations_ сервиса који су покренути на појединачном чвору. Извршава се ручно или као део поступка гашења кластера. Њена основна улога је да обезбеди чисто и безбедно гашење процеса како би се избегли проблеми при поновном покретању система. 

Процес заустављања обухвата следеће кораке: 
1. извоз (енгл. _export_) вредности из `node.env` датотеке у окружење виртуелне машине
2. читање PID-a из `/etc/c12s/star.pid` датотеке
3. провера да ли прочитани PID припада `star` процесу
4. убијање `star` процеса 
5. гашење сервиса дефинисаних у `node.yml` датотеци помоћу _Docker Compose_-a 

=== Покретање _control plane_-а
Скрипта `control_plane_start.sh` задужена је за иницијализацију и покретање централних сервиса који чине _control plane_ систем. Ова компонента представља управљачки слој који координише рад свих чворова у оквиру кластера, обезбеђује размену порука и синхронизацију путем NATS сервиса.

Процес покретања обухвата неколико корака:
1. извоз (енгл. _export_) вредности из `control_plane.env` датотеке у окружење _host_ машине
2. покретање свих неопходних сервиса дефинисаних у `control_plane.yml` датотеци помоћу _Docker Compose_-a 
3. покретање _scylla_ сервиса
4. покретање _Grafana_ сервиса

=== Заустављање _control plane_-а
Скрипта `control_plane_stop.sh` задужена је за контролисано гашење свих сервиса који чине _control plane_. Њена улога је да обезбеди правилно ослобађање ресурса и спречи неконзистентност у раду система након заустављања.

Процес заустављања обухвата следеће кораке:
1. извоз (енгл. _export_) вредности из `control_plane.env` датотеке у окружење _host_ машине
2. гашење _Grafana_ сервиса
3. гашење _scylla_ сервиса
4. гашење свих сервиса дефинисаних у `control_plane.yml` датотеци помоћу _Docker Compose_-a 

#pagebreak()

На листингу #link(<lst:control_plane_start>)[15] приказани су сервиси дефинисани у оквиру `control_plane.yml` датотеке који се покрећу на _host_ машини помоћу _Docker Compose_-a.

#figure(
```yaml
version: "3.8"

services:
  magnetar:
    # ...
  oort:
    # ...
  kuiper:
    # ...
  quasar:
    # ...
  agent_queue:
    # ...
  apollo:
    # ...
  vault:
    # ...
  neo4j:
    # ...
  nats:
    # ...
  etcd:
    # ...
  kuiper_etcd:
    # ...
  quasar_etcd:
    # ...
  scylla:
    # ...
  lunar-gateway:
    # ...
  consul:
    # ...
  rate_limiter_service:
    # ...
  meridian:
    # ...
  meridian_neo4j:
    # ...
  pulsar:
    # ...
  pulsar_etcd:
    # ...
  protostar_healthcheck:
    # ...
  protostar_metrics:
    # ...
  prometheus_healthcheck:
```,
    caption: [Сервиси дефинисани у `control_plane.yml` датотеци.]
)<lst:control_plane_start>